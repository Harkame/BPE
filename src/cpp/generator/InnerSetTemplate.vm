#ifndef $innerSetClassNameDefine
#[[#define]]# $innerSetClassNameDefine


#[[#include]]# "inner_set.hpp"
#[[#include]]# " $previousInnerSet.hpp "

using namespace std;

template<typename T>
class $innerSetClassName : public inner_set<T>
{
    public :
        struct values
        {
            #foreach($element in $elements) T $element#if( $foreach.hasNext); #end#end;
        } a_values;

        $innerSetClassName<T>();
        $innerSetClassName<T>(#foreach($element in $elements)T #if( $foreach.hasNext ), #end#end);
        $innerSetClassName<T>($previousInnerSet<T>, T);

        virtual ~$innerSetClassName<T>();

        virtual inner_set<T>* add_element(T);
        virtual inner_set<T>* add_elements(T*);

        virtual bool contains_element(T);
        virtual bool contains_all_elements(T*);

        virtual T get_element(int);

        virtual inner_set<T>* remove_element(T);

        virtual inner_set<T>* retain_all_element(T*);

        virtual int get_size();
};

#endif

#[[#include]]# " $innerSetClassName.hpp "

template<typename T>
$innerSetClassName<T>::$innerSetClassName()
{

}

template<typename T>
$innerSetClassName<T>::$innerSetClassName(#foreach($element in $elements)T p_element_$foreach.count#if( $foreach.hasNext ), #end#end)
{
    #foreach($element in $elements)
        a_values.$element = p_element_$foreach.count;
    #end
}

template<typename T>
$innerSetClassName<T>::$innerSetClassName($previousInnerSet<T> p_inner_set, T p_element)
{
    #foreach($element in $elements)
        #if( $foreach.hasNext )a_values.$element = p_inner_set.a_values.element_$foreach.count;#end
    #end
    a_values.element_$innerSetOffset = p_element;
}

template<typename T>
$innerSetClassName<T>::~$innerSetClassName()
{

}

                                                template<typename T>
inner_set<T>* $innerSetClassName<T>::add_element(T p_element)
{
    if(!contains_element(p_element))
        return new $nextInnerSet<T>(this, p_element);
    else
        return this;
}

template<typename T>
inner_set<T>* $innerSetClassName<T>::add_elements(T* p_elements)
{
    return nullptr; //TODO
}

template<typename T>
bool $innerSetClassName<T>::contains_element(T p_element)
{
    return #foreach($element in $elements) a_values.$element == p_element#if( $foreach.hasNext) || #end#end;
}

template<typename T>
bool $innerSetClassName<T>::contains_all_elements(T* p_elements)
{
    return false; //TODO
}

template<typename T>
T $innerSetClassName<T>::get_element(int p_index)
{
    return reinterpret_cast<T*>(&a_values)[p_index];
}

template<typename T>
inner_set<T>* $innerSetClassName<T>::remove_element(T p_element)
{
    #foreach($el in $elements)
        #set( $f = $foreach )
        #set($sep = "")
        if($el == p_element)
            return new $previousInnerSet<T>(#foreach($element in $elements)#if($f.count != $foreach.count)$sep$element#set($sep = ", ")#end#end);
        #if( $f.hasNext ) else #end
    #end
    else
        return this;
}

template<typename T>
inner_set<T>* $innerSetClassName<T>::retain_all_element(T* p_elements)
{
    return this; //TODO
}

template<typename T>
int $innerSetClassName<T>::get_size()
{
    return $innerSetOffset;
}
